
# План: обратимый фикс‑размерный «капсюль» строки → базовые «энергии» → SNN → обратный проход (macOS · Swift · M4 · CPU/GPU)

_С определённой долей вероятности ≈ 85 %: этот план позволит собрать прототип быстро, с заделом на улучшения. Скептически относимся к «магии», каждую фазу фиксируем тестами и метриками._

**Контекст интеграции:** выходом «капсюля» будет **печатная строка фиксированной длины** (или её числовой эквивалент), которую мы далее преобразуем в массив малых целых «энергий» и подаём в вашу архитектуру маршрутизации (см. документ про «энергетический роутер» — он будет использоваться как чёрный ящик; интеграционные точки отмечены явно).

---

## 0) Цели и требования (коротко)

- **Детерминизм** и **обратимость** преобразования «строка → фикс‑размерный капсюль → строка».  
- **Фиксированный размер вывода**, настраиваемый через конфиг: `maxInputBytes` и итоговый размер блока `N` байт.  
- **Простое отображение капсюля в массив «энергий»**: базовая позиционная система счисления (по умолчанию — **base‑100**) даёт числа `1..100` (можно подогнать под вашу нотацию «1 → 1», «a → 11» с помощью алфавита).  
- **Производительность на Apple Silicon (M4)**: CPU (Accelerate/BNNS, vDSP, simd) + GPU (Metal) + многопоточность (Swift Concurrency/GCD).  
- **Проверка целостности**: CRC32 и служебный заголовок; при необходимости — Reed–Solomon (позже).  
- **Эффект Тезена**: при ошибке/шуме на выходе SNN минимально разрушать обратимость — будут механизмы «щадящей» квантизации обратно к допустимым цифрам base‑B.

---

## 1) Выбор схемы обратимости (концепт)

Сжать произвольную строку в фиксированный размер **без коллизий** нельзя, если не ограничить вход. Поэтому:

- Задаём `L_max` (максимальное число байт UTF‑8).  
- Готовим **блок N байт**: `Header || Data || Padding`  
  - `Header`: 1–2 байта длины + 4 байта CRC32 (опционально версия+флаги).  
  - `Data`: первые `len` байт UTF‑8.  
  - `Padding`: нули до размера `N`.  
- Поверх блока применяем обратимую перестановку/PRP (pseudorandom permutation): 
  - **v0**: простая Feistel‑сеть (CPU; учебная, без криптографии).  
  - **v1**: AES‑ECB/CTR с фиксированным ключом через CryptoKit (на Apple Silicon это очень быстро).  
  - **v2**: собственная перестановка на GPU (Metal) — пригодится, если захотите обучать ключ как параметр.

> Вывод: «капсюль» = ровно `N` байт. Он обратим при знании ключа/параметров и не зависит от длины исходной строки (в пределах `L_max`).

---

## 2) Отображение капсюля в «энергии» (base‑B)

Чтобы получить массив малых целых чисел для SNN, используем **основание B** и **алфавит длины B**.

- По умолчанию **`B = 100`** → цифры `0..99`, а мы используем **1‑индексацию** → `1..100`.  
- Имеем двунаправленное преобразование:
  - `bytes[N] → digits[D]` (основание 256 → основание B), где `D = ceil(N·log2(256)/log2(B))` — константа для данного `N`.  
  - `digits[D] → printable string` по настраиваемому **алфавиту** длины `B` (например, первым символом — `'1'`, одиннадцатым — `'a'`, чтобы «1→1, a→11»).  
- Для **энергий** в SNN используем массив `E[D]`, где `E[i] = digits[i] + 1 ∈ [1..B]`.
- **Нормализация** (если нужна вещественная подача): `x[i] = E[i] / (B+1)` или z‑score по батчу.

> Важно: `D` фиксирован для данного `N` и `B` → на вход модели всегда подаётся вектор одной длины.

---

## 3) Общая архитектура проекта (Swift Package + App)

```
ReversibleCapsule/
├─ Sources/
│  ├─ CapsuleCore/
│  │  ├─ Config.swift          # конфиг с N, L_max, B, alphabet, ключ, режимы
│  │  ├─ Header.swift          # длина, версия, CRC32
│  │  ├─ Feistel.swift         # v0 PRP (CPU)
│  │  ├─ AESBackend.swift      # v1 PRP (CryptoKit, аппаратно-ускоренное)
│  │  ├─ BaseB.swift           # bytes<->digits (основание B), digits<->string
│  │  ├─ EnergyMapper.swift    # digits -> энергии [1..B] и обратно
│  │  ├─ Roundtrip.swift       # encode/decode, проверки, ошибки
│  │  └─ Metrics.swift         # тайминги, длины, ошибки CRC
│  ├─ GPU/
│  │  ├─ MetalKernels/
│  │  │  ├─ prp_feistel.metal  # необязательное PRP/GPU (v2)
│  │  │  └─ baseb.metal        # массивные преобразования для батчей
│  │  └─ MetalBackend.swift
│  ├─ BridgeSNN/
│  │  ├─ RouterIO.swift        # адаптер к вашей SNN (энергии <-> капсюль)
│  │  └─ Datasets.swift        # генераторы тестовых строк/батчей
│  ├─ CLI/
│  │  ├─ main.swift            # `swift run capsule --config ...`
│  │  └─ Args.swift
│  └─ UI/
│     ├─ CapsuleApp.swift
│     ├─ Views/
│     │  ├─ CapsuleView.swift  # визуализация: строка, капсюль, энергии
│     │  └─ BenchView.swift    # профилирование, пропускная способность
├─ Tests/
│  ├─ RoundtripTests.swift     # строки -> капсюль -> строки (рандом/edge cases)
│  ├─ BaseBTests.swift         # корректность оснований и обратимости
│  ├─ FeistelTests.swift       # инвертируемость PRP
│  └─ PerfTests.swift          # бенчмарки CPU/GPU
├─ Configs/
│  ├─ baseline.yaml
│  └─ high_throughput.yaml
└─ Package.swift
```

---

## 4) Фазы и шаги реализации

### Фаза A. Базовая инфраструктура (0.5–1 день)
1. **SwiftPM**: библиотека + исполняемая цель; минимум зависимостей (стандартные фреймворки).  
2. **Config** (`baseline.yaml`):  
   ```yaml
   version: 1
   max_input_bytes: 256     # L_max (можно менять в рантайме)
   block_size: 320          # N (>= header + L_max)
   base: 100                # B
   alphabet: "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ..."
   prp: "feistel"           # feistel | aes | gpu_feistel
   feistel_rounds: 10
   key_hex: "000102..."     # для AES/Feistel; можно оставить нули в MVP
   ```
3. **Логирование/метрики**: os.signpost; CSV для бенчмарков.  
4. **CLI**: `encode`, `decode`, `to-energies`, `from-energies`, `bench`.

_Уверенность ≈ 95 % (технически тривиально)._

---

### Фаза B. Обратимый капсюль v0 (CPU, Feistel)
1. **Header**: `len: UInt16`, `crc32: UInt32`, `flags: UInt8`.  
2. **Упаковка**: UTF‑8 → проверка `len ≤ L_max` → паддинг до `N`.  
3. **PRP‑ядро (Feistel)**:  
   - Полублоки по `N/2`; раунд‑функция на BLAKE2s/HMAC‑SHA256 (из стандартной CryptoKit).  
   - Число раундов `r=10` (для MVP).  
   - Тест: прямой→обратный проход для 1000 случайных строк.
4. **Ошибки**: несоответствие CRC → «неверный капсюль»; полезно при обратном проходе из SNN.

_Уверенность ≈ 90 % (стабильно для MVP)._

---

### Фаза C. Отображение bytes ↔ digits (base‑B) ↔ printable
1. **bytes→digits**: алгоритм длинного деления (big‑int вектор) или пакетная конверсия по 4/8 байт для ускорения.  
2. **digits→bytes**: умножение/сложение в основании B с переносами.  
3. **Алфавит**: массив `alphabet[B]` + обратный индекс `indexOf[char]`.  
4. **Проверка**: совпадение размера `D = ceil(N·8 / log2(B))` и обратимость на 10⁴ кейсов.  
5. **Нотация «1→1, a→11»**: просто расставьте алфавит так, чтобы `'1'` был на позиции 1, `'a'` — на позиции 11; цифры — 1‑индексируются.

_Уверенность ≈ 90 %._

---

### Фаза D. Массив «энергий» ↔ SNN‑роутер
1. **Encoder**: `capsule (N bytes) → digits[D] → energies[D]∈[1..B]`.  
2. **Нормализация**: опционально `Float32` `x[i]=E[i]/(B+1)`; сохраняем версию нормализации в заголовке.  
3. **Adapter API (`BridgeSNN/RouterIO.swift`)**:  
   ```swift
   struct Capsule { let bytes: [UInt8] }         // ровно N
   struct Energies { let values: [UInt16] }      // ровно D
   func makeEnergies(from capsule: Capsule) -> Energies
   func recoverCapsule(from energies: Energies) -> Capsule?
   ```
4. **Интеграция с «энергетическим роутером»**: входной слой ожидает вектор длины `D`; при обратном проходе — выдаёт такой же `D`. (См. план роутера; интеграция точек I/O.)

_Уверенность ≈ 85 %._

---

### Фаза E. Обратный проход после SNN (квантизация и защита)
1. **Квантайзер**: `Float32 x[i] → round to nearest in {1..B}` с клиппингом `[1..B]`.  
2. **Санитайзер последовательности**: проверка, что все `digits ∈ [0..B-1]` после сдвига `-1`.  
3. **Декодирование**: `digits → bytes → (PRP^{-1}) → Header/Data`.  
4. **CRC**: несоответствие → стратегия исправления:  
   - локальная переборка нескольких соседних цифр (beam‑search ширины 2–3) для восстановления;  
   - ограничение числа шагов (таймаут) и возврат «не удалось».

_Уверенность ≈ 80 % (работает на умеренном уровне шума)._

---

### Фаза F. Производительность (M4, многопоточность, GPU)
1. **CPU‑ускорение**:  
   - vDSP/Accelerate для операций над векторами (копии, суммирования, умножения при base‑B).  
   - `withUnsafeMutableBytes` и `simd` для пакетных 16‑/32‑байтных шагов.  
   - Пулы буферов, избегать аллокаций на горячем пути.  
2. **Swift Concurrency**:  
   - `TaskGroup` по батчам; размер группы = числу производительных ядер.  
   - Для редукций использовать пер‑поточные накопители и финальную агрегацию.  
3. **AES‑вариант (v1)**: CryptoKit на Apple Silicon обычно использует аппаратные инструкции — на M‑серии это очень быстро (с определённой долей вероятности ≈ 90 %).  
4. **GPU‑ускорение (v2)**:  
   - Metal compute для массовых конверсий `bytes↔digits` по батчам и/или PRP‑перестановок.  
   - Выравнивание буферов по 256 байтам; `MTLHeap` для переиспользования.  
   - Параллельные command buffers для независимых батчей.  
5. **Профилирование**: Instruments: Time Profiler, GPU Counters; `os_signpost` вокруг этапов `pack→prp→baseB→energies`.

_Уверенность ≈ 80–85 %._

---

### Фаза G. Тесты и верификация
1. **Round‑trip**: рандомные строки (в т.ч. кириллица, эмодзи) длиной `0..L_max`.  
2. **Edge‑кейсы**: пустая строка, максимально длинная, невалидная UTF‑8 (ожидаем ошибку), многобайтовые символы.  
3. **Шум SNN**: симулировать отклонения ±1..3 по случайным позициям и оценить процент успешного восстановления.  
4. **Бенчмарк**: throughput (капсулей/сек), латентность, использование CPU/GPU/памяти.

_Уверенность ≈ 90 %._

---

### Фаза H. Улучшения (по мере надобности)
- **Ошибка‑коррекция**: добавить «тонкий» код: CRC32C + Hamming(8,4) на блок цифр или лёгкий RS‑код.  
- **Версионирование**: `flags.version` в Header; при смене алфавита/основания сохраняем обратную совместимость.  
- **Адаптивное основание**: `B ∈ {64, 85, 100}` — баланс длины строки (меньше для B=85) и удобства «1..B».  
- **Инвертируемая пермутация без ключа**: PRP с публичными параметрами (Feistel на фиксированных константах) — удобно для отладки.  
- **Параметризуемое `L_max`** в рантайме: при изменении — автоматически пересчитывать `N` и `D` (или валидировать конфиг).

_Уверенность ≈ 75–85 %._

---

## 5) Скелеты API (Swift)

```swift
// MARK: - Config
public struct CapsuleConfig: Sendable, Codable {
    public var maxInputBytes: Int // L_max
    public var blockSize: Int     // N
    public var base: Int          // B
    public var alphabet: [Character] // длина B
    public var prp: PRPKind       // .feistel | .aes | .gpuFeistel
    public var feistelRounds: Int
    public var key: Data          // ключ PRP (может быть нули в MVP)
}

// MARK: - Header
struct Header {
    var len: UInt16
    var flags: UInt8
    var crc32: UInt32
}

// MARK: - Encode/Decode (высокоуровневые)
public struct Capsule { public let bytes: [UInt8] } // ровно N

public enum CapsuleError: Error { case tooLong, badAlphabet, crcMismatch, invalidConfig }

public func encodeString(_ s: String, cfg: CapsuleConfig) throws -> Capsule
public func decodeString(_ c: Capsule, cfg: CapsuleConfig) throws -> String

// MARK: - Energies Bridge
public struct Energies { public let values: [UInt16] } // длина D, 1..B

public func toEnergies(_ c: Capsule, cfg: CapsuleConfig) -> Energies
public func fromEnergies(_ e: Energies, cfg: CapsuleConfig) -> Capsule? // nil если не прошла CRC

// MARK: - Helper
public func digitsCount(N: Int, base B: Int) -> Int {
    let bits = N * 8.0
    return Int((bits / (B.bit_length_log2()))).addingReportingOverflow(0).0 + 1
}
```

*(В реальном коде `digitsCount` аккуратно считать через `log2` или таблично; округление — `ceil`.)*

---

## 6) Подбор параметров по умолчанию (MVP)

- `L_max = 256 байт`, `N = 320 байт` (1+‑заголовок + запас под рост).  
- `B = 100`, алфавит длиной 100: начинаем с `['1','2',...,'9','0','a','b',...,'z','A',...,'Z', '.', ',', '-', '_', ':', ';', '(', ')', ' ']` (подгоните позиции, чтобы `'1'→1`, `'a'→11`).  
- **PRP v0**: Feistel×10 раундов (CPU). **v1**: AES‑CTR/ECB (CryptoKit).  
- **Нормализация**: `E[i]/101.0` на вход SNN.  
- **Квантайзер**: round+clip на выходе SNN; до 2–3 итераций локальной корректировки при срыве CRC.

_Уверенность ≈ 85 %._

---

## 7) Риски и тактические ответы

- **Коллизии**: в пределах `L_max` и фиксированного `N` коллизий нет (биекция на множество допустимых блоков). (≈95 %)  
- **Шум на выходе SNN**: добавлен CRC и локальный поиск; можно усилить RS‑кодом. (≈80 %)  
- **Производительность base‑B**: CPU хватит, но при батчевой обработке выгодно вынести конверсию на GPU. (≈75 %)  
- **Юникод**: храним UTF‑8 «как есть» → обратимость и устойчивость к произвольным символам. (≈90 %)

---

## 8) Как это связывается с «энергетическим роутером»

- **Вход** роутера: вектор длины `D` (энергии `1..B`) — можно подать прямо; либо нормализованный `Float32`.  
- **Выход** роутера: тот же `D`; после квантизации → `digits` → `capsule` → обратный PRP → `String`.  
- Метрики: доля успешных обратных восстановлений, средняя правка при корректировке, энтропия на входе/выходе.

---

## 9) Улучшения, специфичные под вашу задачу

- **Обучаемый алфавит**: порядок символов в алфавите можно сделать обучаемым параметром (перестановка), если фиксировать его версию в Header.  
- **Energy budget**: если SNN использует «бюджет энергии», можно ограничивать сумму `Σ E[i]` через простую нормировку без потери обратимости (скейл известен и обратим).  
- **Мульти‑блок**: для очень длинных сообщений — режим «цепочки» капсулей с номерами блоков и финальным мерклизованным контрольным суммированием.

---

## 10) Короткая дорожная карта (сроки для MVP)

- День 1: Фаза A+B (CPU‑капсюль, Feistel), Round‑trip тесты.  
- День 2: Фаза C+D (base‑B, энергии, Bridge к SNN), простая CLI.  
- День 3: Фаза E+F (квантайзер, метрики, бенчмарк; при необходимости AES‑вариант).  
- День 4+: Профили, GPU‑ускорение, улучшения.

---

### Примечание о стиле уверенности
- Факты про обратимость и ограничения — ≈95 %.  
- Рекомендации по производительности на Apple Silicon — ≈85–90 % (реально подтверждаются профилированием).  
- Влияние шума и эффективность локального поиска — ≈70–80 % (зависит от вашей SNN).

