# Лист‑шпаргалка: метрики и профилирование (Energetic Router · macOS · Swift · M‑series)

_С определённой долей вероятности ≈ 85 %: набор ниже охватывает «что мерить» и «как искать узкие места» именно для событийно‑поточной маршрутизации энергии с мягким/дискретным роутингом, CPU/GPU гибридом и UI._

---

## 1) Метрики обучения и маршрутизации

### 1.1. Качество задачи
- **loss** — основная (CE/MSE).  
- **accuracy / MAE** — по задаче (классификация/регрессия).
- **baseline_reward** — скользящее среднее награды (если используется RL/локальные правила).
- **reward** — сырая награда по батчу/эпохе (r или −loss).

**Триггеры тревоги:** loss «пилит» без нисходящего тренда > N итераций; reward≈baseline.

---

### 1.2. Маршрутизация (политика)
- **entropy(π)** — средняя энтропия распределения по рёбрам (чем ниже, тем жестче выбор).  
  - Цель: на ранних этапах **высокая**, затем плавное снижение.
- **topK‑usage** — доля случаев, когда решение действительно в top‑K.
- **policy‑KL(prev||curr)** — насколько сильно «скачет» политика между шагами.
- **route_length** — средняя/макс длина пути (если «прыжки»); **% коротких/дальних** путей.
- **unique_paths** — число уникальных маршрутов в батче/эпохе.

**Триггеры тревоги:** entropy→0 слишком рано (policy collapse); KL скачет сильно (нестабильность); route_length уходит в экстремумы.

---

### 1.3. Энергетика
- **sum_energy_in / out** — суммарная энергия на входе/выходе слоя; разность (утечки/взрывы).  
- **max_node_energy / max_edge_flow** — верхние перцентили (p95/p99) по узлам/рёбрам.
- **active_ratio** — доля активных узлов/рёбер (энергия > ε).
- **energy_clip_events** — число срабатываний клиппинга за шаг.
- **norm_outgoing_weights** — распределение суммы исходящих весов по узлам; стат. контроль (среднее, σ).

**Триггеры тревоги:** систематический рост sum_energy; частые clip‑events; всплески p99 потоков.

---

### 1.4. Локальные правила (Hebb/RL)
- **eligibility_norm** — средняя норма `E_{jk}` (и p95/p99).  
- **Δw_norm / sign_ratio** — средняя норма/доля положительных/отрицательных апдейтов.  
- **reward‑corr(E,Δw)** — корреляция между наградой и изменениями весов.  
- **baseline_drift** — скорость изменения baseline (если есть).

**Триггеры тревоги:** Δw_norm→0 (обучение «уснуло») или взрыв; сильный перекос знака; baseline дрейфует быстро.

---

### 1.5. Стабильность и численная гигиена
- **NaN/Inf count** — любые появления.  
- **grad_norm** — нормы градиентов (если backprop для роутера).  
- **param_norm** — нормы параметров Q/K/b/W.  
- **lr_tuner** — актуальная скорость обучения и β Adam (для логов).

**Триггеры тревоги:** NaN/Inf; grad_norm «пилит» в насыщении; param_norm дрейфует без ограничений.

---

### 1.6. UI/перф‑метрики (онлайн)
- **fps_ui** — кадры в секунду (если визуализация включена).  
- **step_time_ms** — время на шаг обучения/инференса.  
- **gpu_util / cpu_util** — загрузка, если возможно (агрегаты).  
- **mem_resident_mb** — резидентная память процесса.

**Триггеры тревоги:** fps падает < 20 при небольших графах; step_time растёт при фиксированном размере батча.

---

## 2) Схема логирования

### 2.1. Частота
- **каждый шаг**: loss, entropy(π), sum_energy, step_time_ms.  
- **каждые N шагов**: accuracy/MAE, unique_paths, route_length, p95 потоков, Δw_norm.  
- **каждая эпоха**: полные распределения (гистограммы) и снапшоты весов.

### 2.2. Форматы
- **CSV/JSON Lines** для метрик (включая timestamp и step/epoch).  
- **Binary** чекпойнты параметров; **JSON** экспорт графа/политики для оффлайн‑визуализации.

### 2.3. Идентификаторы эксперимента
- `exp_id`, `git_rev`, `seed`, `config_hash`, `backend(cpu/gpu)`, `headless`.

---

## 3) Чек‑лист sanity‑тестов (до больших прогонов)
1. **Энергосохранение на пустом графе**: нет потоков → нули на выходе.  
2. **Равномерная политика** (τ→∞): равномерное распределение по исходящим рёбрам; суммарная энергия сохраняется.  
3. **Детерминизм seeds**: одинаковые сиды → совпадают метрики и пути.  
4. **Численная проверка градиента** (малый граф): finite differences согласуются с аналитикой.  
5. **Клиппинг/нормировка**: при искусственном «взрыве» потоков стабилизируются до безопасных уровней.

_Оценка уверенности: ≈ 90 %._

---

## 4) Профилирование: Instruments (пошагово)

### 4.1. Подготовка
- **os_signpost** в коде: метки `forward`, `backward`, `update`, `visualize`.  
- Сборка `-c release`; символы оставляем.  
- Набор команд (CLI):  
  ```bash
  swift build -c release
  sudo xcrun xctrace record \
    --template "Time Profiler" \
    --time-limit 60s \
    -- swift run energetic --config Configs/baseline.yaml --headless
  ```

### 4.2. Сценарии трассировки
1. **CPU — Time Profiler**  
   - Цель: «горячие функции» (softmax по сегментам, редукции, Adam).  
   - KPIs: % времени в top‑3 функциях; IPC/branch misses; кэш‑промахи.
2. **GPU — Metal System Trace / GPU Counters**  
   - Цель: занятость GPU, латентность командных буферов, время ядер `router/energy`.  
   - KPIs: occupancy, threadgroup utilization, memory bytes/sec, barriers/stalls.
3. **Память — Allocations / Memory Graph**  
   - Цель: пулы буферов, отсутствие «мусорных» аллокаций в главном цикле.  
   - KPIs: аллокации/сек, живые объекты, удерживаемые буферы.
4. **System Trace**  
   - Цель: взаимодействие потоков, конкуренция за CPU/GPU, влияние UI.  
   - KPIs: срезы по ядрам performance/efficiency, preemption, wakeups.

_Оценка уверенности: ≈ 85 %._

---

## 5) Быстрый «плейбук» оптимизаций

### 5.1. CPU
- Векторизация через Accelerate (vDSP/BLAS) для dot/softmax редукций.  
- Пер‑поточные буферы и последующая редукция (избежать атомиков в горячем пути).  
- Устранение аллокаций в цикле (предварительные пулы/arena).

### 5.2. GPU (Metal)
- **Сегментированный softmax**: сортировать рёбра, чтобы сегменты были похожей длины.  
- Использовать `threadgroup` память для сумм; избегать ветвлений внутри варпа.  
- Коалесцированные чтения/записи; выравнивание буферов (≥128‑байт).  
- Минимизировать количество маленьких диспатчей (слияние).

### 5.3. Гибрид
- Передавать на GPU **крупные мат‑участки** (логиты/softmax/редукции).  
- Держать локальные правила/домашниеostasis на CPU (ветвистая логика).  
- Параллелить независимые батчи (несколько командных буферов).

### 5.4. UI
- Отрисовывать **top‑K** рёбра; батчировать геометрию.  
- Регулируемый FPS; отключаем визуализацию при профилировании.

_Оценка уверенности: ≈ 80 %._

---

## 6) Пороговые «охранники» (runtime guards)
- **energy_guard**: если `sum_energy_out > C·sum_energy_in + ε` → аварийная нормировка.  
- **nan_guard**: NaN/Inf в метриках → немедленный снапшот и останов.  
- **entropy_guard**: `entropy(π)<ε` до шага T → увеличить τ/λ энтропии.  
- **step_time_guard**: рост `step_time_ms` на >X % за Y шагов без изменения конфигурации → лог + профилирование.

---

## 7) Мини‑доска качественных критериев
- **Обучение**: loss↓ монотонно, acc/MAE улучшается; entropy плавно ↓; unique_paths стабильно ↑.  
- **Стабильность**: sum_energy стабилизирована; clip‑events редки и убывают; NaN/Inf — ноль.  
- **Перф**: step_time_ms держится при росте размера графа по ожидаемой сложности; GPU/CPU загружены «плотно».

---

## 8) Команды для стандартных трасс

```bash
# Time Profiler (CPU), 60 секунд
sudo xcrun xctrace record \
  --template "Time Profiler" \
  --time-limit 60s \
  -- swift run energetic --config Configs/baseline.yaml --headless

# Metal System Trace (GPU), 60 секунд
sudo xcrun xctrace record \
  --template "Metal System Trace" \
  --time-limit 60s \
  -- swift run energetic --config Configs/baseline.yaml --headless

# Allocations (память), 30 секунд
sudo xcrun xctrace record \
  --template "Allocations" \
  --time-limit 30s \
  -- swift run energetic --config Configs/baseline.yaml --headless
```

---

### Итог
_С определённой долей вероятности ≈ 85 %: удерживая эти метрики и чек‑лист в ежедневном цикле, вы получите управляемый прогресс без «чёрных ящиков» — и сможете сравнивать backprop‑базовую линию с локальными правилами на равных._
