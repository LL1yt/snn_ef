# План: обратимый фикс‑размерный «капсюль» строки → базовые «энергии» → SNN → обратный проход (macOS · Swift · M4 · CPU/GPU)

_С определённой долей вероятности ≈ 85 %: этот план позволит собрать прототип быстро, с заделом на улучшения. Скептически относимся к «магии», каждую фазу фиксируем тестами и метриками._

**Контекст интеграции:** выходом «капсюля» будет **печатная строка фиксированной длины** (или её числовой эквивалент), которую мы далее преобразуем в массив малых целых «энергий» и подаём в вашу архитектуру маршрутизации (см. документ про «энергетический роутер» — он будет использоваться как чёрный ящик; интеграционные точки отмечены явно).

---

## 0) Цели и требования (коротко)

- **Детерминизм** и **обратимость** преобразования «строка → фикс‑размерный капсюль → строка».
- **Фиксированный размер вывода**, настраиваемый через конфиг: `maxInputBytes` и итоговый размер блока `N` байт.
- **Простое отображение капсюля в массив «энергий»**: базовая позиционная система счисления (по умолчанию — **base‑256**) даёт числа `1..256` (можно подогнать под вашу нотацию «1 → 1», «a → 11» с помощью алфавита).
- **Производительность на Apple Silicon (M4)**: CPU (Accelerate/BNNS, vDSP, simd) + GPU (Metal) + многопоточность (Swift Concurrency/GCD).
- **Проверка целостности**: CRC32 и служебный заголовок; при необходимости — Reed–Solomon (позже).
- **Эффект Тезена**: при ошибке/шуме на выходе SNN минимально разрушать обратимость — будут механизмы «щадящей» квантизации обратно к допустимым цифрам base‑B.

---

## 1) Выбор схемы обратимости (концепт)

Сжать произвольную строку в фиксированный размер **без коллизий** нельзя, если не ограничить вход. Поэтому:

- Задаём `L_max` (максимальное число байт UTF‑8).
- Готовим **блок N байт**: `Header || Data || Padding`
  - `Header`: 1–2 байта длины + 4 байта CRC32 (опционально версия+флаги).
  - `Data`: первые `len` байт UTF‑8.
  - `Padding`: нули до размера `N`.
- Поверх блока применяем обратимую перестановку/PRP (pseudorandom permutation):
  - **v0**: простая Feistel‑сеть (CPU; учебная, без криптографии).
  - **v1**: AES‑ECB/CTR с фиксированным ключом через CryptoKit (на Apple Silicon это очень быстро).
  - **v2**: собственная перестановка на GPU (Metal) — пригодится, если захотите обучать ключ как параметр.

> Вывод: «капсюль» = ровно `N` байт. Он обратим при знании ключа/параметров и не зависит от длины исходной строки (в пределах `L_max`).

---

## 2) Отображение капсюля в «энергии» (base‑B)

Чтобы получить массив малых целых чисел для SNN, используем **основание B** и **алфавит длины B**.

- По умолчанию **`B = 256`** → цифры `0..255`, а мы используем **1‑индексацию** → `1..256`.
- Имеем двунаправленное преобразование:
  - `bytes[N] → digits[D]` (основание 256 → основание B), где `D = ceil(N·log2(256)/log2(B))` — константа для данного `N`.
  - `digits[D] → printable string` по настраиваемому **алфавиту** длины `B` (например, первым символом — `'1'`, одиннадцатым — `'a'`, чтобы «1→1, a→11»).
- Для **энергий** в SNN используем массив `E[D]`, где `E[i] = digits[i] + 1 ∈ [1..B]`.
- **Нормализация** (если нужна вещественная подача): `x[i] = E[i] / (B+1)` или z‑score по батчу.

> Важно: `D` фиксирован для данного `N` и `B` → на вход модели всегда подаётся вектор одной длины.

---

## 3) Общая архитектура проекта (Swift Package + App)

```
ReversibleCapsule/
├─ Sources/
│  ├─ SharedInfrastructure/
│  │  ├─ ConfigCenter.swift   # переиспользуем общий слой конфигов/валидации
│  │  ├─ LoggingHub.swift     # уровни логов, process_id
│  │  └─ ProcessRegistry.swift# словарь стадий пайплайна
│  ├─ CapsuleCore/
│  │  ├─ Config.swift          # конфиг с N, L_max, B, alphabet, ключ, режимы
│  │  ├─ Header.swift          # длина, версия, CRC32
│  │  ├─ Feistel.swift         # v0 PRP (CPU)
│  │  ├─ AESBackend.swift      # v1 PRP (CryptoKit, аппаратно-ускоренное)
│  │  ├─ BaseB.swift           # bytes<->digits (основание B), digits<->string
│  │  ├─ EnergyMapper.swift    # digits -> энергии [1..B] и обратно
│  │  ├─ Roundtrip.swift       # encode/decode, проверки, ошибки
│  │  └─ Metrics.swift         # тайминги, длины, ошибки CRC
│  ├─ GPU/
│  │  ├─ MetalKernels/
│  │  │  ├─ prp_feistel.metal  # необязательное PRP/GPU (v2)
│  │  │  └─ baseb.metal        # массивные преобразования для батчей
│  │  └─ MetalBackend.swift
│  ├─ BridgeSNN/
│  │  ├─ RouterIO.swift        # адаптер к вашей SNN (энергии <-> капсюль)
│  │  └─ Datasets.swift        # генераторы тестовых строк/батчей
│  ├─ CLI/
│  │  ├─ main.swift            # `swift run capsule --config ...`
│  │  └─ Args.swift
│  └─ UI/
│     ├─ CapsuleApp.swift
│     ├─ Views/
│     │  ├─ CapsuleView.swift  # визуализация: строка, капсюль, энергии
│     │  └─ BenchView.swift    # профилирование, пропускная способность
├─ Tests/
│  ├─ RoundtripTests.swift     # строки -> капсюль -> строки (рандом/edge cases)
│  ├─ BaseBTests.swift         # корректность оснований и обратимости
│  ├─ FeistelTests.swift       # инвертируемость PRP
│  └─ PerfTests.swift          # бенчмарки CPU/GPU
├─ Configs/
│  ├─ baseline.yaml
│  └─ high_throughput.yaml
└─ Package.swift
```

---

## Совместный инфраструктурный слой (с «энергетическим роутером»)

- **ConfigCenter**: единая точка входа для конфигурации (размеры капсюля, base-B, маршрутизатор, визуализация). Снапшот immutable на шаг, переключение профилей через CLI и YAML.
- **LoggingHub**: централизованное логирование с уровнями (`trace/debug/info/warn/error`) и обязательным `process_id` (`capsule.encode`, `capsule.baseB`, `router.step`, `router.spike`, `ui.pipeline` и т.д.).
- **ProcessRegistry**: словарь стадий пайплайна, используемый логами, метриками и UI для прямого сопоставления событий.
- **Сборки**: headless-билд тянет только `CapsuleCore + SharedInfrastructure`, UI-билд добавляет `CapsuleUI`; SwiftPM таргеты разделены, чтобы визуал можно было подключать позже.
- **Fail-fast**: любые несогласованные параметры, ошибка CRC, превышение `L_max`, NaN/Inf → немедленный `throw` без скрытых фолбеков; CLI и UI обязаны показать ошибку пользователю.
- **Документация конфига**: полная схема ключей и пример базового профиля лежат в `Docs/config_center_schema.md` (обязательный референс для обоих модулей).

---

## 4) Фазы и шаги реализации

### Фаза A. Базовая инфраструктура (0.5–1 день)

1. **SwiftPM**: библиотека + исполняемая цель; минимум зависимостей (стандартные фреймворки).
2. **ConfigCenter / `baseline.yaml`**: полный YAML приведён в `Docs/config_center_schema.md`. Ниже — фрагмент, относящийся к капсюлю:
   ```yaml
   capsule:
     enabled: true
     max_input_bytes: 256
     block_size: 320
     base: 256
     alphabet: "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_.:,() "
     prp: feistel
     feistel_rounds: 10
     key_hex: "000102030405060708090a0b0c0d0e0f"
     normalization: e_over_bplus1
     pipeline_example_text: "Hello, Energetic Router!"
     crc: crc32
     gpu_batch: 512
   ```
   - Конфиг загружается через `ConfigCenter` (SharedInfrastructure), валидируется и снабжается `process_id` для стадий капсюля.
   - Один профиль описывает сразу капсюль и роутер (размеры, base-B, UI); изменения требуют перезапуска, без «горячих» фолбеков.
3. **Логирование/метрики**: события пишем через `LoggingHub` (JSON + текст), уровни настраиваются в конфиге; `os_signpost` подключаем для профилирования.
4. **CLI**: `encode`, `decode`, `to-energies`, `from-energies`, `bench`, `--ui`/`--headless`; каждая команда отправляет `process_id` в лог.
5. **Ошибки/валидация**: любое нарушение (`len > L_max`, неправильный алфавит, CRC mismatch) → `throw`; UI/CLI показывают ошибку и завершают шаг.

_Уверенность ≈ 95 % (технически тривиально)._

---

### Фаза B. Обратимый капсюль v0 (CPU, Feistel)

1. **Header**: `len: UInt16`, `crc32: UInt32`, `flags: UInt8`.
2. **Упаковка**: UTF‑8 → проверка `len ≤ L_max` → паддинг до `N`.
3. **PRP‑ядро (Feistel)**:
   - Полублоки по `N/2`; раунд‑функция на BLAKE2s/HMAC‑SHA256 (из стандартной CryptoKit).
   - Число раундов `r=10` (для MVP).
   - Тест: прямой→обратный проход для 1000 случайных строк.
4. **Ошибки**: несоответствие CRC → «неверный капсюль»; полезно при обратном проходе из SNN.

_Уверенность ≈ 90 % (стабильно для MVP)._

---

### Фаза C. Отображение bytes ↔ digits (base‑B) ↔ printable

1. **bytes→digits**: алгоритм длинного деления (big‑int вектор) или пакетная конверсия по 4/8 байт для ускорения.
2. **digits→bytes**: умножение/сложение в основании B с переносами.
3. **Алфавит**: массив `alphabet[B]` + обратный индекс `indexOf[char]`.
4. **Проверка**: совпадение размера `D = ceil(N·8 / log2(B))` и обратимость на 10⁴ кейсов.
5. **Нотация «1→1, a→11»**: просто расставьте алфавит так, чтобы `'1'` был на позиции 1, `'a'` — на позиции 11; цифры — 1‑индексируются.

_Уверенность ≈ 90 %._

---

### Фаза D. Массив «энергий» ↔ SNN‑роутер

1. **Encoder**: `capsule (N bytes) → digits[D] → energies[D]∈[1..B]`.
2. **Нормализация**: опционально `Float32` `x[i]=E[i]/(B+1)`; сохраняем версию нормализации в заголовке.
3. **Adapter API (`BridgeSNN/RouterIO.swift`)**:
   ```swift
   struct Capsule { let bytes: [UInt8] }         // ровно N
   struct Energies { let values: [UInt16] }      // ровно D
   func makeEnergies(from capsule: Capsule) -> Energies
   func recoverCapsule(from energies: Energies) -> Capsule?
   ```
4. **Интеграция с «энергетическим роутером»**: входной слой ожидает вектор длины `D`; при обратном проходе — выдаёт такой же `D`. (См. план роутера; интеграция точек I/O.)
5. **Логирование/трейс**: каждый вызов `makeEnergies` и `recoverCapsule` отправляет событие в `LoggingHub` (`process_id`: `capsule.encoder`, `capsule.decoder`), чтобы UI могла отображать реальные значения.

_Уверенность ≈ 85 %._

---

### Фаза E. Обратный проход после SNN (квантизация и защита)

1. **Квантайзер**: `Float32 x[i] → round to nearest in {1..B}` с клиппингом `[1..B]`.
2. **Санитайзер последовательности**: проверка, что все `digits ∈ [0..B-1]` после сдвига `-1`.
3. **Декодирование**: `digits → bytes → (PRP^{-1}) → Header/Data`.
4. **CRC**: несоответствие → стратегия исправления:
   - локальная переборка нескольких соседних цифр (beam‑search ширины 2–3) для восстановления;
   - ограничение числа шагов (таймаут) и возврат «не удалось».

_Уверенность ≈ 80 % (работает на умеренном уровне шума)._

---

### Фаза F. Производительность (M4, многопоточность, GPU)

1. **CPU‑ускорение**:
   - vDSP/Accelerate для операций над векторами (копии, суммирования, умножения при base‑B).
   - `withUnsafeMutableBytes` и `simd` для пакетных 16‑/32‑байтных шагов.
   - Пулы буферов, избегать аллокаций на горячем пути.
2. **Swift Concurrency**:
   - `TaskGroup` по батчам; размер группы = числу производительных ядер.
   - Для редукций использовать пер‑поточные накопители и финальную агрегацию.
3. **AES‑вариант (v1)**: CryptoKit на Apple Silicon обычно использует аппаратные инструкции — на M‑серии это очень быстро (с определённой долей вероятности ≈ 90 %).
4. **GPU‑ускорение (v2)**:
   - Metal compute для массовых конверсий `bytes↔digits` по батчам и/или PRP‑перестановок.
   - Выравнивание буферов по 256 байтам; `MTLHeap` для переиспользования.
   - Параллельные command buffers для независимых батчей.
5. **Профилирование**: Instruments: Time Profiler, GPU Counters; `os_signpost` вокруг этапов `pack→prp→baseB→energies`.

_Уверенность ≈ 80–85 %._

---

### Фаза G. Тесты и верификация

1. **Round‑trip**: рандомные строки (в т.ч. кириллица, эмодзи) длиной `0..L_max`.
2. **Edge‑кейсы**: пустая строка, максимально длинная, невалидная UTF‑8 (ожидаем ошибку), многобайтовые символы.
3. **Шум SNN**: симулировать отклонения ±1..3 по случайным позициям и оценить процент успешного восстановления.
4. **Бенчмарк**: throughput (капсулей/сек), латентность, использование CPU/GPU/памяти.

_Уверенность ≈ 90 %._

---

### Фаза H. Улучшения (по мере надобности)
- **Ошибка‑коррекция**: добавить «тонкий» код: CRC32C + Hamming(8,4) на блок цифр или лёгкий RS‑код.  
- **Версионирование**: `flags.version` в Header; при смене алфавита/основания сохраняем обратную совместимость.  
- **Адаптивное основание**: `B` можно варьировать (`{64, 128, 256}` и т.п.); текущий профиль использует `B=256` ради плотности и фиксированной длины printable строки.  
- **Инвертируемая пермутация без ключа**: PRP с публичными параметрами (Feistel на фиксированных константах) — удобно для отладки.  
- **Параметризуемое `L_max`** в рантайме: при изменении — автоматически пересчитывать `N` и `D` (или валидировать конфиг).

_Уверенность ≈ 75–85 %._

---

### Фаза I. Визуализация пайплайна (после MVP)

1. **CapsulePipelineView**: UI-модуль, который подписывается на `LoggingHub` (`process_id`: `ui.pipeline`) и воспроизводит фактический проход `строка → капсюль → digits → энергии → SNN → обратная строка`.
2. **Наглядные блоки**:
   - Вход: часть исходного текста (первые/последние 32 символа) + длина/CRC.
   - Капсюль: hex-дамп первых/последних 16 байтов и позиция внутри блока.
   - Основание B: список первых 16 и последнего digit'ов с коэффициентами.
   - Энергии: значения `E[i]` и нормализованные `x[i]`, если применялись.
   - SNN-выход: показ `Δx/Δy` и восстановленные цифры/строка с пометкой успешности CRC.
3. **Шаги**: кнопки `next/prev`, автовоспроизведение; headless-режим сохраняет тот же трейс в JSON (`pipeline_snapshot.json`) для офлайн анализа.
4. **Ошибки**: любые расхождения (например, CRC mismatch) подсвечиваются, UI выводит содержимое ошибки без попытки скрыть её.

_Уверенность ≈ 80 % (визуализация «настоящих» данных заметно упрощает отладку)._

---

## 5) Скелеты API (Swift)

```swift
// MARK: - Config
public struct CapsuleConfig: Sendable, Codable {
    public var maxInputBytes: Int // L_max
    public var blockSize: Int     // N
    public var base: Int          // B
    public var alphabet: [Character] // длина B
    public var prp: PRPKind       // .feistel | .aes | .gpuFeistel
    public var feistelRounds: Int
    public var key: Data          // ключ PRP (может быть нули в MVP)
}

// MARK: - Header
struct Header {
    var len: UInt16
    var flags: UInt8
    var crc32: UInt32
}

// MARK: - Encode/Decode (высокоуровневые)
public struct Capsule { public let bytes: [UInt8] } // ровно N

public enum CapsuleError: Error { case tooLong, badAlphabet, crcMismatch, invalidConfig }

public func encodeString(_ s: String, cfg: CapsuleConfig) throws -> Capsule
public func decodeString(_ c: Capsule, cfg: CapsuleConfig) throws -> String

// MARK: - Energies Bridge
public struct Energies { public let values: [UInt16] } // длина D, 1..B

public func toEnergies(_ c: Capsule, cfg: CapsuleConfig) -> Energies
public func fromEnergies(_ e: Energies, cfg: CapsuleConfig) -> Capsule? // nil если не прошла CRC

// MARK: - Helper
public func digitsCount(N: Int, base B: Int) -> Int {
    let bits = N * 8.0
    return Int((bits / (B.bit_length_log2()))).addingReportingOverflow(0).0 + 1
}
```

_(В реальном коде `digitsCount` аккуратно считать через `log2` или таблично; округление — `ceil`.)_

---

## 6) Подбор параметров по умолчанию (MVP)

- `L_max = 256 байт`, `N = 320 байт` (1+‑заголовок + запас под рост).  
- `B = 256`, алфавит длиной 256: используем непрерывный диапазон `U+0100…U+01FF` (Latin Extended-A/B) без управляющих символов; порядок букв задаёт прямое преобразование `digit → char`.
- **PRP v0**: Feistel×10 раундов (CPU). **v1**: AES‑CTR/ECB (CryptoKit).  
- **Нормализация**: `E[i]/101.0` на вход SNN.  
- **Квантайзер**: round+clip на выходе SNN; до 2–3 итераций локальной корректировки при срыве CRC.

_Уверенность ≈ 85 %._

---

## 7) Риски и тактические ответы

- **Коллизии**: в пределах `L_max` и фиксированного `N` коллизий нет (биекция на множество допустимых блоков). (≈95 %)
- **Шум на выходе SNN**: добавлен CRC и локальный поиск; можно усилить RS‑кодом. (≈80 %)
- **Производительность base‑B**: CPU хватит, но при батчевой обработке выгодно вынести конверсию на GPU. (≈75 %)
- **Юникод**: храним UTF‑8 «как есть» → обратимость и устойчивость к произвольным символам. (≈90 %)

---

## 8) Как это связывается с «энергетическим роутером»

- **Вход** роутера: вектор длины `D` (энергии `1..B`) — можно подать прямо; либо нормализованный `Float32`.
- **Выход** роутера: тот же `D`; после квантизации → `digits` → `capsule` → обратный PRP → `String`.
- Метрики: доля успешных обратных восстановлений, средняя правка при корректировке, энтропия на входе/выходе.

---

## 9) Улучшения, специфичные под вашу задачу

- **Обучаемый алфавит**: порядок символов в алфавите можно сделать обучаемым параметром (перестановка), если фиксировать его версию в Header.
- **Energy budget**: если SNN использует «бюджет энергии», можно ограничивать сумму `Σ E[i]` через простую нормировку без потери обратимости (скейл известен и обратим).
- **Мульти‑блок**: для очень длинных сообщений — режим «цепочки» капсулей с номерами блоков и финальным мерклизованным контрольным суммированием.

---

## 10) Короткая дорожная карта (сроки для MVP)

- День 1: Фаза A+B (CPU‑капсюль, Feistel), Round‑trip тесты.
- День 2: Фаза C+D (base‑B, энергии, Bridge к SNN), простая CLI.
- День 3: Фаза E+F (квантайзер, метрики, бенчмарк; при необходимости AES‑вариант).
- День 4+: Профили, GPU‑ускорение, улучшения.

---

### Примечание о стиле уверенности

- Факты про обратимость и ограничения — ≈95 %.
- Рекомендации по производительности на Apple Silicon — ≈85–90 % (реально подтверждаются профилированием).
- Влияние шума и эффективность локального поиска — ≈70–80 % (зависит от вашей SNN).
