# Фаза 2: EnergeticRouter SNN (CPU-first) — краткая сводка

## Обзор

**Цель**: построить потоковый EnergeticRouter, где каждое энерго-«зерно» движется по временной сетке в равномерном ритме, а спайки (SNN) решают, когда и куда совершать дискретные прыжки вперёд. Никаких заранее перечисленных направлений: нейрон предсказывает смещения в пределах допустимых диапазонов по X/Y.

**Опорные идеи**:
- время дискретно, базовое движение всегда вперёд по оси X (следующий слой);
- мембранный потенциал узла копит вклад от энергии и координат, спайк возникает при превышении порога и инициирует прыжок;
- координаты смещения вычисляются на лету, затем квантуются/нормализуются к допустимому диапазону (`Δx`, `Δy`);
- ConfigCenter задаёт диапазоны, пороги и затухание; CPU-ветка на Accelerate — эталон, проект сразу пригоден к переносу на MPS;
- энергия потоков не смешивается до окончания, `stream_id` гарантирует отслеживание.

---

## Основные компоненты

### 1. TemporalGrid
- `TemporalGrid.swift`: структура с размерами (`layers`, `nodes_per_layer`) и правилами нормализации координат.
- По оси X (слой) работает «floor»: если выходим за правую границу — поток попадает в выходной буфер.
- По оси Y используется тор (wrap-around), чтобы не ограничивать эмерджентность.

### 2. SpikingKernel
- `SpikingKernel.swift`: общий для всех узлов SNN-элемент с мембранным потенциалом.
- Вход: нормализованные `(x, y, e, t/T)`; обновление: `V ← λ·V + W·input`.
- Выход: 
  - `energy_next` (скаляр для следующего шага),
  - `delta_xy` (не-нормированное смещение), которое после `tanh` масштабируется диапазоном (`Δx_range`, `Δy_range`),
  - `spike_flag = (V ≥ θ)` c последующим сбросом `V`.

### 3. SpikeRouter
- `SpikeRouter.swift`: основной исполнитель.
- На каждом шаге:
  1. продвигает поток на `x+1`;
  2. подавляет энергию через `SpikingKernel` → `energy_next`;
  3. если произошёл спайк — вычисляет новую целевую позицию `x + clamp(round(Δx), 1..Δx_max)`; `y` смещается и берёт модуль по `nodes_per_layer`;
  4. формирует новый `EnergyPacket` (остается `stream_id`, обновляется энергия).
- Выход за последний слой собирается в `OutputAccumulator`.

### 4. EnergyFlow
- `EnergyPacket.swift`: хранит `stream_id`, координаты и энергию.
- `EnergyFlowSimulator.swift`: шаговая итерация, буферизация энергии до финального слоя, сбор результатов (`stream_id → суммарная энергия`).

### 5. Обучение
- `SNNLosses.swift`: 
  - `energyBalanceLoss` — удерживает суммарную энергию (`α·input` ≈ `output`);
  - `spikeTargetLoss` — опционально сравнивает желаемую геометрию с фактическими спайками;
  - суррогатные градиенты (например, fast sigmoid) для пороговой функции;
  - регуляризатор для `Δx`, `Δy`, чтобы прыжки не уходили за допустимые пределы.
- `TrainingLoop.swift`: surrogate backprop или локальные правила (STDP), обновление параметров через Adam.

### 6. Метрики и логирование
- `RouterMetrics.swift`: число спайков, средняя энергия, отклонение от порога, распределение `Δx/Δy`.
- `RouterLogger.swift`: события `router.step`, `router.spike`, `router.overflow`.
- `PipelineSnapshot`: сохраняет траектории потоков и параметры SNN для headless/UI.

---

## Порядок реализации

```
Этап 1: TemporalGrid + Config — границы, нормализация, тесты диапазонов
Этап 2: SpikingKernel — мембранная динамика, surrogates, векторизация
Этап 3: SpikeRouter + EnergyFlow — потоковая логика и буферы
Этап 4: Обучение — лоссы, surrogate градиенты, Adam
Этап 5: Метрики/логирование — события, snapshot, headless экспорт
```

---

## Критерии завершения

- **Функциональность**:
  - поток двигается шаг за шагом без смешения по `stream_id`;
  - спайк инициирует прыжок в допустимом диапазоне, координаты корректно квантованы;
  - выходные энергии собираются в буфер последнего слоя;
  - ConfigCenter принимает диапазоны (`Δx_range`, `Δy_range`, `decay`, `threshold`), fail-fast при нарушении инвариантов.

- **Тесты**:
  - детерминированный шаговый тест (без спайков) — энергия движется строго вдоль оси X;
  - тест со спайком — проверка wrap-around по Y и проекции на выход при `x > layers-1`;
  - surrogate градиенты проходят численную проверку на малой сетке;
  - energy balance держится в пределах допуска `ε`.

- **Логирование**:
  - `router.spike` содержит `stream_id`, `Δx`, `Δy`, `energy_before`, `energy_after`;
  - snapshot хранит список активных потоков и их траектории;
  - headless режим записывает `Artifacts/pipeline_snapshot.json` с той же структурой.

---

## Конфигурация (baseline.yaml, новые поля)

```yaml
router:
  layers: 10
  nodes_per_layer: 1024
  snn:
    decay: 0.92
    threshold: 0.8
    reset_value: 0.0
    delta_x_range: [1, 4]      # сколько слоёв можно перепрыгнуть
    delta_y_range: [-128, 128] # шаги по индексу, y оборачивается
    surrogate: "fast_sigmoid"
    dt: 1                      # шаг времени (целое)
  alpha: 0.9                   # базовое затухание энергии
  energy_floor: 1.0e-5         # гашение слишком мелких потоков
  training:
    optimizer:
      type: "adam"
      lr: 1.0e-3
      beta1: 0.9
      beta2: 0.999
      eps: 1.0e-8
    losses:
      energy_balance_weight: 1.0
      jump_penalty_weight: 1.0e-2
      spike_rate_target: 0.1
```

ConfigCenter валидирует диапазоны (`delta_x_range.min >= 1`, `delta_y_range.min < 0 < max`) и соответствие `router.energy_constraints.energy_base == capsule.base`.

---

## После фазы 2

- Подключаем Capsule ↔ Router: энергии превращаются в начальные спайковые состояния (поток на layer=0).
- UI: визуализация временной ленты и событий спайков; headless пишет полный трек.
- GPU: перенос SpikingKernel на MPS (batched update мембраны и энергий), затем SpikeRouter на Metal.

**Статус**: готово к реализации; все ссылки на прежний плотный/softmax роутер удалены.
